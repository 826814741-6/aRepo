--
--  _helper.lua: some helper functions
--

--
-- >> LuaJIT is fully upwards-compatible with Lua 5.1. It supports all
-- >> standard Lua library functions and the full set of Lua/C API functions.
-- >> -- https://luajit.org/extensions.html
-- >>
-- >> math.abs (x)
-- >> Returns the absolute value of x.
-- >> -- https://www.lua.org/manual/5.1/manual.html#pdf-math.abs
--
-- > print(math.abs(0), math.abs(-0), math.abs(0.0), math.abs(-0.0))
-- 0       0       0       0
-- > print(type(math.abs(-0)), type(math.abs(-0.0)))
-- number  number
--
-- > ffi = require "ffi"
-- > ffi.cdef "long labs(long);"
-- > = ffi.C.labs(-0LL)
-- 0LL
--

local function atLeastOne(n) return n>1 and n or 1 end

local d_sethook = debug.sethook

local function count(f, ...)
	local c = 0
	d_sethook(function() c = c + 1 end, "c")
	f(...)
	d_sethook()
	return c
end

local function isBool(v)
	return type(v) == "boolean"
end

local function isFh(v)
	return io.type(v) == "file"
end

local function isFun(v)
	return type(v) == "function"
end

local function isNum(v)
	return type(v) == "number"
end

local function isStr(v)
	return type(v) == "string"
end

local function isTbl(v)
	return type(v) == "table"
end

local function isUd(v)
	return type(v) == "userdata"
end

local function isBoolOrNil(v)
	return type(v) == "boolean" or v == nil
end

local function isFhOrNil(v)
	return io.type(v) == "file" or v == nil
end

local function isNumOrNil(v)
	return type(v) == "number" or v == nil
end

local d_getinfo = debug.getinfo

local function getNumOfParams(f)
	return d_getinfo(f).nparams
end

local function getValueOrNil(predicate, v)
	if predicate(v) then
		return v
	else
		return nil
	end
end

local function getValueOrInit(predicate, v, initialValue)
	if predicate(v) then
		return v
	else
		return initialValue
	end
end

local function mustBeBool(v)
	assert(type(v) == "boolean", "Must be a boolean.")
	return v
end

local function mustBeNum(v)
	assert(type(v) == "number", "Must be a number.")
	return v
end

local function mustBeStr(v)
	assert(type(v) == "string", "Must be a string.")
	return v
end

-- local function readOnlyTable(t)
--   ...
-- end
-- see: http://lua-users.org/wiki/ReadOnlyTables
--      https://www.lua.org/pil/13.4.5.html
--      (the last part of) https://www.lua.org/pil/13.3.html

local function file(path, mode, body)
	local _, fh = pcall(io.open, path, mode)
	assert(isFh(fh), "file(): Something wrong with your 'path' or/and 'mode'.")

	local ret, v = pcall(body, fh)
	fh:close()
	assert(ret == true, v)
end

local function gChecker(fmt, filter)
	return isFun(filter) and
		function (self, target)
			for i,v in ipairs(self.validators) do
				assert(
					v(target[i]),
					fmt:format(filter(i), d_getinfo(2, "n").name))
			end
		end or
		function (self, target)
			for i,v in ipairs(self.validators) do
				assert(
					v(target[i]),
					fmt:format(i, d_getinfo(2, "n").name))
			end
		end
end

local function makeValidator(validators, checker)
	local T = { validators = validators }

	T.check = checker ~= nil
		and checker
		or function (self, target)
			for i,v in ipairs(self.validators) do
				assert(v(target[i]), i)
			end
		end

	return T
end

local t_unpack = table.unpack ~= nil and table.unpack or unpack

local function wrapWithValidator(body, paramValidator, returnValidator, unpacker)
	unpacker = unpacker ~= nil and unpacker or t_unpack
	return setmetatable({}, {
		__call = function (self, ...)
			local arg = {...}
			paramValidator:check(arg)

			local ret = {body(...)}
			returnValidator:check(ret)

			return unpacker(ret)
		end
	})
end

return {
	atLeastOne = atLeastOne,
	count = count,
	isBool = isBool,
	isFh = isFh,
	isFun = isFun,
	isNum = isNum,
	isStr = isStr,
	isTbl = isTbl,
	isUd = isUd,
	isBoolOrNil = isBoolOrNil,
	isFhOrNil = isFhOrNil,
	isNumOrNil = isNumOrNil,
	getNumOfParams = getNumOfParams,
	mustBeBool = mustBeBool,
	mustBeNum = mustBeNum,
	mustBeStr = mustBeStr,
	file = file,
	gChecker = gChecker,
	makeValidator = makeValidator,
	wrapWithValidator = wrapWithValidator
}
