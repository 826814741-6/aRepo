--
--  from src/sqrt.c
--
--    double mysqrt(double)      to  fSqrt
--
--  from src/isqrt.c
--
--    unsigned isqrt(unsigned)   to  iSqrt
--
--  from src/cuberoot.c
--
--    double cuberoot(double)    to  fCbrt
--    double cuberoot2(double)   to  fCbrt2
--
--  from src/icubrt.c
--
--    unsigned icubrt(unsigned)  to  iCbrt
--

local H = require '_helper'

local abs, atLeastOne = H.abs, H.atLeastOne
local b_lshift, b_rshift, m_floor = bit.lshift, bit.rshift, math.floor

local function gLoop(step)
	return function (x)
		local prev, t = atLeastOne(x), step(x, atLeastOne(x))
		while t < prev do
			prev, t = t, step(x, t)
		end
		return prev
	end
end

local loopS, loopC1, loopC2 =
	gLoop(function (x, t) return (x/t + t) / 2 end),
	gLoop(function (x, t) return (x / (t*t) + 2*t) / 3 end),
	gLoop(function (x, t) return t + (x - t*t*t) / (2*t*t + x/t) end)

local function initC(loop)
	return function (x)
		if x == 0 then
			return 0
		elseif x > 0 then
			return loop(x)
		else
			return -loop(abs(x))
		end
	end
end

--

local function fSqrt(x)
	if x <= 0 then return 0 end
	return loopS(x)
end

local fCbrt, fCbrt2 = initC(loopC1), initC(loopC2)

local function iSqrt(x)
	if x <= 0 then return 0 end

	local r, t = x, 1
	while t < r do
		r, t = b_rshift(r, 1), b_lshift(t, 1)
	end
	repeat
		r, t = t, b_rshift((m_floor(x / t) + t), 1)
	until t >= r

	return r
end

local function loopI(x)
	local r, t = x, 1
	while t < r do
		r, t = b_rshift(r, 2), b_lshift(t, 1)
	end
	repeat
		r, t = t, m_floor((m_floor(x / (t * t)) + 2 * t) / 3)
	until t >= r
	return r
end

local iCbrt = initC(loopI)

return {
	fSqrt = fSqrt,
	iSqrt = iSqrt,
	fCbrt = fCbrt,
	fCbrt2 = fCbrt2,
	iCbrt = iCbrt
}
